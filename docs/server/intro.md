# phecda-server
渐进的、类型复用的，函数粒度的类`nestjs`服务端框架


:::tip need to konw
1. 长得像`nestjs`的`trpc`，
2. 低侵入
3. 基于依赖注入的`phecda-core`标准，
:::

 我认为它在`monorepo`项目上能够提供一流的体验与标准，我目前正在多个项目中实践`phecda-server`

 即使是大型项目,由于渐进+低侵入，迁移上手简单，风险低

 目前支持`express`/`fastify`/`h3`/`koa`,微服务支持`redis`/`rabbitmq`


## 灵感来源
先从一个`nestjs`案例开始
> 这是一个登录的接口，只需要在浏览器端，朝着`/user/login`发请求就行，

```ts
@Controller('/user')
class User {
  @Post('/login')
  login(@Query('name') name: string, @Query('password') password: string) { // 仔细看这一行！
    // ..

    return true
  }
}
```
一件不难看出的事情是：这里其实已经提供了请求参数的类型和返回值的类型，只需要想法设法让类型能被前端所利用。

另一件很关键的事情是：服务端只是需要两个参数，至于这两个参数来自`body`还是其他地方，通过`Get`还是`Post`,走的路由是什么，服务端自己是知道的！

既然服务端是知道的，那么开发者是否可以不用知道？

这给我了一点想法：

我可不可以让接口的调用，变成函数的调用，也就是，我只关心入参和返回的值，至于这个参数是挂载到`body`还是`query`，是走什么路由，是`GET`还是`POST`,我不用去管（屏蔽掉`HTTP`这个层面的东西，完全回归到函数这个层级上），

如果可以的话，那么前端中完全可以这么调用:

```ts
const ret = await login('fgs', '123456')// 这样就可以直接复用服务端类型！
```
这种改造成`函数`的方式有很多，[详见](./compare.md)，

而我更希望其能够符合`RESTFUL`的标准，方便迁移，让使用者更能接受一点

一个不算坏的方案是：服务端得到一些元数据，包含路由，请求方式等信息，然后创建可被前端利用的代码。

前端利用这些基础代码再去创建基本请求

> 写法上和`nestjs`基本保持一致，也有守卫/管道/拦截器/过滤器，但能够实现`trpc`类似的类型复用，即` 长得像nestjs的trpc`；

这种屏蔽实现细节，仅暴露函数调用的思路，不仅仅能用于`express`等服务端框架,`rabbitmq`等一样可以,即`跨技术栈`;
关于依赖注入，[详见](./nestjs.md)


