# 关于4.0的考量
> break change!!

如果只是考虑`浏览器<->服务端`，3.0的版本已经提供了完美的体验，热更新真的是个非常棒的东西。

但我试图将其移植到微服务这个层面时，遇到了麻烦。

先说一下，其实本来没什么麻烦，但`phecda-server`是基于三个点：

1. 渐进式

不能使用约定！像`httpc`/`tsrpc`都是很棒的项目，但那种远程`rpc`都是基于某种约定实现的，如果`PS`也这么做，那和重新写一个项目没什么区别了

要以附加的形式，可以随时解除、回退：以`redis`为例，不能是`PS`内部创建redis实例+操作，要能直接附加到现有的redis实例

2. 复用
要追求配置、类型都只写一次，不用多次定义，这会有如下问题：

`ts`不支持`url`做类型提示，几乎只能考虑npm安装（monorepo）
如果`http`的写法在微服务中起效，要考虑兼容的问题
nodejs几乎不会使用`vite`等打包工具，只能通过`--import`去编译，这很不方便

3. 函数粒度
`PS`要在渐进的基础上，实现`rpc`远程函数调用的效果，底层屏蔽多次调用的负担

既然是函数，那就有入参和返回值，既要给函数值，又要接收函数返回的值，而诸如`redis`/`mq`，都是生产/消费模型，如果要返回值，就要麻烦的多（`nestjs`专门进行了补充）
`http`层面有专用路由，可以将几次调用合并到一次请求，在`rpc`中实现感觉意义不大，


## 更改
更改内容如下

1. 区分`http`/`rpc`，`rpc`之间只会区分对象，不会区分实现（比如可以限制这个rpc只用redis，但无论是用什么，写法一致）
现在存在四种角色：`Controller`只为`http`服务，`RPC`只为`http`服务，`Module/Service`为前两者服务服务。

`Controller`中使用`Get`等来决定请求方法，使用`Body`等来决定请求参数，

`RPC`使用`Rpc`来标明这是个`rpc`，使用`Arg`来搞定参数

> 虽然可以在`Controller`中标记`Rpc`，这能起效，但别这么做！

2. 不再生成`meta`,给消费端去编译，而是直接生成`js`代码，去伪造出一些类，运行类上的方法，得到配置信息（只会产生接口的方法）

3. 现在有两种情况，分别是`一个请求对应一个方法`（rpc/http）和`一个请求对应多个方法`（http专用路由）

`@Middle`对应中间件只用于`http`的请求,且不用于专用路由，其他所有，无论拦截器、守卫、管道、过滤器都是面向`方法`，可以在`http/rpc`中使用。
但注意，虽然面对都是`方法`，但除了管道一定会操作方法的入参，后置拦截器会操作方法返回值，其他主要都是操作上下文，而不是操作方法本身

这意味着在走专用路由时，有可能调用同个守卫、拦截器多次，

4. 一个上下文`Context`只针对一个方法

> 3.0聚焦`请求`这个层级，守卫、拦截器等都是对于`请求`的，一次请求对应一个上下文
