import{_ as e,c as o,o as c,a2 as d}from"./chunks/framework.OWRZTr7j.js";const m=JSON.parse('{"title":"关于4.0的考量","description":"","frontmatter":{},"headers":[],"relativePath":"server/other/changelog.md","filePath":"server/other/changelog.md","lastUpdated":1719282362000}'),t={name:"server/other/changelog.md"},p=d('<h1 id="关于4-0的考量" tabindex="-1">关于4.0的考量 <a class="header-anchor" href="#关于4-0的考量" aria-label="Permalink to &quot;关于4.0的考量&quot;">​</a></h1><blockquote><p>break change!!</p></blockquote><p>如果只是考虑<code>浏览器&lt;-&gt;服务端</code>，3.0的版本已经提供了完美的体验，热更新真的是个非常棒的东西。</p><p>但我试图将其移植到微服务这个层面时，遇到了麻烦。</p><p>先说一下，其实本来没什么麻烦，但<code>phecda-server</code>是基于三个点：</p><ol><li>渐进式</li></ol><p>不能使用约定！像<code>httpc</code>/<code>tsrpc</code>都是很棒的项目，但那种远程<code>rpc</code>都是基于某种约定实现的，如果<code>PS</code>也这么做，那和重新写一个项目没什么区别了</p><p>要以附加的形式，可以随时解除、回退：以<code>redis</code>为例，不能是<code>PS</code>内部创建redis实例+操作，要能直接附加到现有的redis实例</p><ol start="2"><li><p>复用 要追求配置、类型都只写一次，不用多次定义，这会有如下问题：</p></li><li><p><code>ts</code>不支持<code>url</code>类型提示，如果不在同一个项目下，类型几乎只能考虑npm安装</p></li><li><p>如果<code>http</code>的写法在微服务中起效，要考虑兼容的问题</p></li><li><p>nodejs几乎不会使用<code>vite</code>等工具做开发，只能通过<code>--import</code>去编译，这很不方便</p></li><li><p>函数粒度，<code>PS</code>要在渐进的基础上，实现<code>rpc</code>远程函数调用的效果，底层屏蔽多次调用的负担。 既然是函数，那就有入参和返回值，既要给函数值，又要接收函数返回的值，而诸如<code>redis</code>/<code>mq</code>，都是生产-消费模型，如果要返回值，就麻烦的多，就要区分返回值/不返回的情况，</p></li></ol><p><code>http</code>层面有专用路由，可以将几次调用合并到一次请求，在<code>rpc</code>中实现感觉意义不大，</p><h2 id="更改" tabindex="-1">更改 <a class="header-anchor" href="#更改" aria-label="Permalink to &quot;更改&quot;">​</a></h2><p>更改内容如下</p><ol><li>区分<code>http</code>/<code>rpc</code>，<code>rpc</code>之间只会区分对象，不会区分实现（比如可以限制这个rpc只用redis，但无论是用什么，写法一致） 现在存在四种角色：<code>Controller</code>只为<code>http</code>服务，<code>RPC</code>只为<code>http</code>服务，<code>Module/Service</code>为前两者服务服务。</li></ol><p><code>Controller</code>中使用<code>Get</code>等来决定请求方法，使用<code>Body</code>等来决定请求参数，</p><p><code>RPC</code>使用<code>Rpc</code>来标明这是个<code>rpc</code>，使用<code>Arg</code>来搞定参数</p><blockquote><p>虽然可以在<code>Controller</code>中标记<code>Rpc</code>，这能起效，但别这么做！</p></blockquote><ol start="2"><li><p>不再生成<code>meta</code>,给消费端去编译，而是直接生成<code>js</code>代码，去伪造出一些类，运行类上的方法，得到配置信息（只会产生接口的方法）</p></li><li><p>有两种情况，分别是<code>一个请求对应一个方法</code>（rpc/http）和<code>一个请求对应多个方法</code>（http专用路由）</p></li></ol><p><code>@Plugin</code>只用于<code>http</code>的请求,且不用于专用路由，其他所有，无论拦截器、守卫、管道、过滤器都是面向<code>方法</code>，可以在<code>http/rpc</code>中使用。 但注意，虽然面对都是<code>方法</code>，但除了管道一定会操作方法的入参，后置拦截器会操作方法返回值，其他主要都是操作上下文，而不是操作方法本身</p><p>这意味着在走专用路由时，有可能调用同个守卫、拦截器多次，</p><ol start="4"><li>一个上下文<code>Context</code>只针对一个方法</li></ol><blockquote><p>3.0聚焦<code>请求</code>这个层级，守卫、拦截器等都是对于<code>请求</code>的，一次请求对应一个上下文</p></blockquote><ol start="5"><li><p><code>PS</code>不能直接操作<code>express</code>实例，只能操作<code>Router</code>，从而保证低侵入</p></li><li><p>专用路由只负责并行请求，放弃串行请求（可以实现得更好，但只会导致无穷的复杂度）</p></li></ol><h2 id="_5-0" tabindex="-1">5.0 <a class="header-anchor" href="#_5-0" aria-label="Permalink to &quot;5.0&quot;">​</a></h2><p>本质没有什么大动作了，只是小更新太多了，已经具备破坏性了，升个大版本检测一下</p>',24),l=[p];function r(a,i,s,h,n,_){return c(),o("div",null,l)}const P=e(t,[["render",r]]);export{m as __pageData,P as default};
