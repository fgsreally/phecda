import{_ as e,c as a,o as s,a2 as i}from"./chunks/framework.BL8mXeqL.js";const m=JSON.parse('{"title":"热更新","description":"","frontmatter":{},"headers":[],"relativePath":"server/advance/hmr.md","filePath":"server/advance/hmr.md","lastUpdated":1718466555000}'),t={name:"server/advance/hmr.md"},l=i('<h1 id="热更新" tabindex="-1">热更新 <a class="header-anchor" href="#热更新" aria-label="Permalink to &quot;热更新&quot;">​</a></h1><p>文件级别的热更新应该是<code>ps</code>独一无二的功能，好像没有同类</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这意味着，开发时不用再重启进程，不需要重复连接数据库，</p><p>加上<code>swc</code>，启动+更新的性能真的是极限中的极限了</p></div><p>简而言之，等同于<code>vite</code>的浏览器热更新</p><p>在我开发这个功能时，因为<code>vite</code>的ssr中热更新api和我预想的不同，只能自己来</p><p>不过需遵守以下：</p><ol><li><code>nodejs</code>版本要支持<code>--import</code>（&gt;v18.18）</li><li>类名/<code>Tag</code>不能更改，这是唯一标识</li><li>需要处理副作用，详见<a href="./module.html#内置模块">模块</a></li><li>由于绝大部分服务端框架不提供注销路由的功能，更改路由的部分可能并无效果，可以完全重启（按r+回车）或者使用<a href="./parallel-route.html">并行路由</a></li></ol><h2 id="开始" tabindex="-1">开始 <a class="header-anchor" href="#开始" aria-label="Permalink to &quot;开始&quot;">​</a></h2><p>安装依赖：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @swc-node/core</span></span></code></pre></div><p>使用命令行工具运行程序</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> phecda</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server.ts</span></span></code></pre></div><p>添加<code>node</code>参数要写在后面</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> phecda</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server.ts</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --inspect</span></span></code></pre></div><blockquote><p>本质就是<code>node --import=phecda-server/register server.js</code></p></blockquote><h2 id="清除副作用" tabindex="-1">清除副作用 <a class="header-anchor" href="#清除副作用" aria-label="Permalink to &quot;清除副作用&quot;">​</a></h2><p>详见<a href="./module.html#内置模块">内置模块</a></p><h2 id="命令行" tabindex="-1">命令行 <a class="header-anchor" href="#命令行" aria-label="Permalink to &quot;命令行&quot;">​</a></h2><p>输入<code>e</code>退出开发 输入<code>r</code>重启进程</p>',19),o=[l];function p(d,h,c,n,r,k){return s(),a("div",null,o)}const g=e(t,[["render",p]]);export{m as __pageData,g as default};
