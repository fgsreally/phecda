import{_ as e,c as o,o as d,a2 as c}from"./chunks/framework.OWRZTr7j.js";const h=JSON.parse('{"title":"bun or deno","description":"","frontmatter":{},"headers":[],"relativePath":"server/advance/bun-or-deno.md","filePath":"server/advance/bun-or-deno.md","lastUpdated":1725094665000}'),n={name:"server/advance/bun-or-deno.md"},a=c('<h1 id="bun-or-deno" tabindex="-1">bun or deno <a class="header-anchor" href="#bun-or-deno" aria-label="Permalink to &quot;bun or deno&quot;">​</a></h1><p>由于<code>ps</code> 运行时使用了 <code>nodejs</code>特有的功能，在<code>bun/deno</code>中不能使用</p><p>一种简单的解决方法是：</p><blockquote><p>前提是服务端框架自身要支持<code>nodejs</code>+<code>bun/deno</code></p></blockquote><ol><li>开发时仍使用<code>nodejs</code>，鉴于快速的热更新，这只会比直接使用<code>deno/bun</code>要快</li><li>生产时通过<code>tsc</code>等工具编译（不能使用<code>unimport/virtualFile</code>等运行时提供的功能）或者<a href="./bundle.html">打包</a>,对产物再使用<code>deno/bun</code></li></ol><p>直白的说，这样可以，但大多数<code>bun/deno</code>的框架都比较新，大多都有独到的设计（并不是指功能，功能反而可以解决，这里是指代码组织形式等东西），比如<code>elysia</code>的类型，如果使用<code>ps</code>，可能会丢失这些宝贵的特性，这太可惜了，</p><blockquote><p><code>ps</code>只是给不同框架提供了一致的体验，而非最合适的体验</p></blockquote>',7),t=[a];function r(s,l,u,_,p,i){return d(),o("div",null,t)}const m=e(n,[["render",r]]);export{h as __pageData,m as default};
