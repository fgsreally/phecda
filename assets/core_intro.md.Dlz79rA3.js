import{_ as o,c,o as d,ae as t}from"./chunks/framework.xEY7gGyy.js";const h=JSON.parse('{"title":"phecda-core","description":"","frontmatter":{},"headers":[],"relativePath":"core/intro.md","filePath":"core/intro.md","lastUpdated":1761991698000}'),a={name:"core/intro.md"};function r(p,e,l,s,i,n){return d(),c("div",null,[...e[0]||(e[0]=[t('<h1 id="phecda-core" tabindex="-1">phecda-core <a class="header-anchor" href="#phecda-core" aria-label="Permalink to &quot;phecda-core&quot;">​</a></h1><blockquote><p>使用了<code>ts</code>的<code>emitDecoratorMetadata</code></p></blockquote><p><code>phecda-core</code>是基于<code>类</code>/<code>装饰器</code>/<code>元数据</code>的一套工具，</p><p>这套工具大概包括三部分功能</p><ol><li>一些工具函数，从而在类上操作元数据</li><li>一个简单的验证方案，类似<code>class-validator</code></li><li>一些标准装饰器--其往类上设置元数据，方便其他基于这套工具的库，如<code>phecda-server/phecda-vue</code>等利用，从而让一套概念可以贯穿到多个环境</li></ol><div class="tip custom-block"><p class="custom-block-title">标准装饰器</p><p>举个例子，如果我需要类上的一个方法，作为监视某个事件的回调</p><p>那么我可以使用<code>@Watcher</code>装饰到方法上，后续<code>phecda-server/phecda-web</code> 会自行理解并实现效果</p><p>其可能在不同的运行环境/不同的业务场景，其实现的方法和基于的库都不一样，但语义上保持了一致</p><p>这样一来，开发者只需要用类表达纯粹的业务逻辑，而不用关心具体的实现细节</p></div><blockquote><p>后续我会把<strong>被<code>phecda</code>装饰器装饰过</strong>的类称为<code>model</code>或模型,实例化的<code>model</code>称为<code>module</code>或模块</p></blockquote>',7)])])}const m=o(a,[["render",r]]);export{h as __pageData,m as default};
