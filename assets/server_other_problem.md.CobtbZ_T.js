import{_ as e,c as o,o as c,a2 as d}from"./chunks/framework.OWRZTr7j.js";const u=JSON.parse('{"title":"注意","description":"","frontmatter":{},"headers":[],"relativePath":"server/other/problem.md","filePath":"server/other/problem.md","lastUpdated":1719282362000}'),t={name:"server/other/problem.md"},r=d('<h1 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意&quot;">​</a></h1><ol><li>所有<code>plugin</code>/<code>guards</code>/<code>interceptor</code>/<code>pipe</code>，都是在同一个命名空间的，所以当项目中存在多个框架（server/rpc）时，请小心命名空间污染。</li></ol><p>以前是每个框架单独一个命名空间，但这看着让我不舒服，一般来讲<code>server</code>只会有一个，而<code>rpc</code>中一般很少用</p><p>如果执意如此，可以使用前缀来解决， 如<code>@Guard(&#39;redis:xx&#39;)</code></p><ol start="2"><li><code>fastify</code>和<code>h3</code>的热更新支持是不完整的，如调整接口路径等不会有效，</li></ol><blockquote><p>因为这些框架没有提供销毁接口的方法</p></blockquote><ol start="3"><li><p>从<code>context</code>中取值必须在<code>controller</code>接口的顶部</p></li><li><p>被实例化的模块不要重名，假设两个类类名相同，tag 不同，那都会被加载，但在客户端中，就没法<code>import</code>了</p></li><li><p>假设一个函数需要使用守卫<code>A</code>，但开发者并没有注入，那么会忽视它，如果希望调用了不存在守卫（or 其他）时抛出错误，可以设置环境变量<code>PS_STRICT</code></p></li><li><p>基于命名空间的考量，<code>PS</code>没有手动实例化模块的功能，也没有处理循环依赖的办法，至少目前如此</p></li><li><p>nodejs 中<code>--import</code>对<code>nodejs</code>的版本有要求：我个人用的是 v21.3.0</p></li><li><p>由于<code>ts</code>的限制，作为依赖复用类型，几乎只有<code>npm</code>一种方式。</p></li></ol>',7),l=[r];function p(a,i,s,n,_,m){return c(),o("div",null,l)}const f=e(t,[["render",p]]);export{u as __pageData,f as default};
