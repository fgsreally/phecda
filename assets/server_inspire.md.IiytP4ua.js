import{_ as s,c as i,o as a,a2 as n}from"./chunks/framework.OWRZTr7j.js";const g=JSON.parse('{"title":"灵感来源","description":"","frontmatter":{},"headers":[],"relativePath":"server/inspire.md","filePath":"server/inspire.md","lastUpdated":1722346040000}'),e={name:"server/inspire.md"},t=n(`<h1 id="灵感来源" tabindex="-1">灵感来源 <a class="header-anchor" href="#灵感来源" aria-label="Permalink to &quot;灵感来源&quot;">​</a></h1><p>先从一个<code>nestjs</code>案例开始</p><p>这是一个登录的接口，只需要在浏览器端，朝着<code>/user/login</code>发请求就行，</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Controller</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/user&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/login&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 仔细看下面这一行！</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  login</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;name&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;password&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">password</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ..</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (password </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;password&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>能看出两件事：</p><h3 id="_1-nestjs的格式已经提供了类型" tabindex="-1">1. <code>nestjs</code>的格式已经提供了类型 <a class="header-anchor" href="#_1-nestjs的格式已经提供了类型" aria-label="Permalink to &quot;1. \`nestjs\`的格式已经提供了类型&quot;">​</a></h3><p>这里提供了请求参数的类型<code>(name:string,password:string)</code></p><p>和返回值的类型(<code>boolean</code>)，</p><p>只需要想法设法让其能被前端利用。</p><h3 id="_2-请求方式-路由-数据位置-无所谓" tabindex="-1">2. 请求方式/路由/数据位置？无所谓 <a class="header-anchor" href="#_2-请求方式-路由-数据位置-无所谓" aria-label="Permalink to &quot;2. 请求方式/路由/数据位置？无所谓&quot;">​</a></h3><p>服务端只是需要两个参数，至于这两个参数来自<code>body</code>还是其他地方，通过<code>Get</code>还是<code>Post</code>,走的路由是什么，服务端自己是知道的！</p><p>既然服务端是知道的，那么开发者是否可以不用知道？</p><p>可不可以让接口的调用，变成函数的调用，也就是，我只关心入参和返回的值，至于这个参数是挂载到<code>body</code>还是<code>query</code>，是走什么路由，是<code>GET</code>还是<code>POST</code>,不用去管（屏蔽掉<code>HTTP</code>这个层面的东西，完全回归到函数这个层级上），</p><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h2><p>这给我了一点想法,前端中完全可以这么调用:</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isLogin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> login</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;phecda-server users&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;password&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这样就可以直接复用服务端类型！</span></span></code></pre></div><p>一个不算坏的方案是：</p><p>服务端得到一些元数据，包含路由，请求方式等信息，然后创建可被前端利用的代码。</p><p>前端通过控制器的类去提供类型，再利用这些基础代码再去创建基本请求</p>`,19),h=[t];function p(l,k,r,d,o,E){return a(),i("div",null,h)}const y=s(e,[["render",p]]);export{g as __pageData,y as default};
